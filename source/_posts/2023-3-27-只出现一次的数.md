---
title: 只出现一次的数
tags:
  - 位运算
categories:
  - 算法
abbrlink: d83a38a1
date: 2023-03-27 16:31:53
---

# 只出现一次的数

题目: 一个数组中, 有两个不同的数出现了一次, 其他的数都恰好出现了两次, 找出这两个数.

原题链接: [260. 只出现一次的数字 III - 力扣（Leetcode）](https://leetcode.cn/problems/single-number-iii/)



---

使用位运算解题需要几点前置知识:

首先, 第一点, 对于任意一个数`N`, 一定满足: `N ^ N == 0`, `0 ^ N == N`;

第二, 位运算异或满足交换律和结合律;

根据第一第二就能推出, 位运算`异或`具有复原性, 即对于任意两个数M和N一定满足: `M^N^N == M`;



那么, 若定义一个变量`eor`对数组中的每一个值, 依次进行`异或`运算, (假设两个不同的数分别为`a`和`b`)则`eor`的值一定等于`a^b`



现在有了`a ^ b`的值`eor`, 怎么求出具体`a`和`b`的值分别是多少呢?

先分析`eor`的值有什么特点, 因为`a`与`b`不等, 所以`eor`一定不为`0` , 

所以其二进制一定有一位为`1`, 在那一位上, 一个为`0`, 一个为`1`(这很重要)

> 例: 比如 `a=1011`, `b=0101`, `eor=a^b= 1110`
>
> 可以发现, `eor`为`1`的位上, `a`和`b`都是一个为`0`一个为`1`

为什么要找那一位`1`? 

找到那一位`1`,  假设为`rightOne`, 那么一定有`rightOne & a == 0` 和 `rightOne & b != 0`, 这样便可以找出两个数的其中一个.

假设找到的是`a`, 那么`b `可以通过 `a ^ eor`获得. (为什么? 因为`eor==a^b` 所以 `a^eor`等于 `a^a^b` , 两个`a`消掉, 就等于`b`了)

> 找到最低位`rightOne = 0010`,可以得到 `0010 & a !=0`, 那么用`0`再对`a`异或就可以得到`a`了
>
> (虽然数组中可能会有很多数, 但是其他数都是只有两个, 经过两次异或运算还是原数, 并不影响, 所以可以想象数组中只有两个数, `a`和`b`)

怎么找到那一位`1`呢? 

通常使用`eor & (~eor + 1)`找出最低位`1` (因为找最低位最方便, 并不是一定要最低位)

一个数的负数的二进制, 等于其*反码加一*(这就像`1+1==2`一样), 所以`eor & (~eor + 1)`也可写为`eor & -eor`

---

看代码

```java
    public int[] singleNumber(int[] nums) {
        int eor = 0;
        for (int num : nums) {
            eor ^= num;
        }
        // 两个数不相同, 所以a^b !== 0, 即其二进制必定有一位 是 1
        int rightOne = eor & -eor;  // 提取最低位的 1
        int onlyOne = 0;
        for (int num : nums) {
            // 条件也可写为 (num & rightOne) != 0
            if ((num & rightOne) == 0) {
                onlyOne ^= num;
            }
        }
        // 与eor异或, 找到另外一个数
        return new int[]{onlyOne, eor ^ onlyOne};
    }
```

